---
uuid: 7873c000-6073-11ec-b012-49e6e10048ce
title: 事件处理
date: 2021-12-19 10:29:19
tags:
---

JavaScript是运行在浏览器端的且是单线程运行的，为了保障DOM渲染和用户操作不相互阻塞，浏览器内核设计了事件机制。比如用户点击了按钮、填写了表单多是可以通过事件监听到并处理的。当然这些事件有一些是浏览器内置的大家可以开箱即用，也允许开发者自定义事件。

### EventTarget 接口

DOM 节点的事件的监听和触发都定义在eventTarget接口。很多对象都实现了这个接口，还有一些浏览器内置对象如 XMLHttpRequest 等也实现了该接口，该接口主要提供三个实例方法。

| 方法                  | 描述        |
| ------------------- | --------- |
| addEventListener    | 绑定事件的监听函数 |
| removeEventListener | 移除事件的监听函数 |
| dispatchEvent       | 触发事件      |

{% showcase event.html event %}

### Tehach

sfsdjkfsjdkjk

```js
const handle = e => {s:1}
dom.addEventListener('click',handle,false)
dom.removeEventListener('click',handle,false)
dom.dispatchEvent(new Event('click'))
```

{% showcase event.html input %}

在此，大家先熟悉这三个接口的使用方法，后续我们会提供一些代码示例。

### 内置事件

事件也称作 DOM 事件，它包括鼠标事件、键盘事件、框架/对象（Frame/Object）事件、表单事件、剪贴板事件、打印事件、拖动事件、多媒体（Media）事件、动画事件、过渡事件等。

![](https://tse4-mm.cn.bing.net/th/id/OIP-C.1l4OcMdQR8o2vGTSoDt-QAHaFS?pid=ImgDet&rs=1)

> 在 HTML 里可以结合 on+event 来绑定事件，浏览器提供了很多内置的事件

```html
<button onclick="(event)=>{console.log(event)}"></button>
```

{% showcase event.html event %}

#### 鼠标事件

```js
dom.addeventListener('click',e=>{})           // 当用户点击某个对象时调用的事件句柄
dom.addeventListener('dblclick',e=>{})        // 当用户双击某个对象时调用的事件句柄
dom.addeventListener('contextmenu',e=>{})     // 在用户点击鼠标右键打开上下文菜单时触发
dom.addeventListener('mousedown',e=>{})       // 鼠标按钮被按下
dom.addeventListener('mousemove',e=>{})       // 鼠标被移动
dom.addeventListener('mouseenter',e=>{})      // 当鼠标指针移动到元素上时触发
dom.addeventListener('mouseover',e=>{})       // 鼠标移到某元素之上
dom.addeventListener('mouseout',e=>{})        // 鼠标从某元素移开
dom.addeventListener('mouseup',e=>{})         // 鼠标按键被松开
dom.addeventListener('mouseleave',e=>{})      // 当鼠标指针移出元素时触发
```

#### 键盘事件

```js
dom.addeventListener('keydown',e=>{})         // 某个键盘按键被按下
dom.addeventListener('keyup',e=>{})           // 某个键盘按键被松开
dom.addeventListener('keypress',e=>{})        // 某个键盘按键被按下并松开
```

#### 框架/对象（Frame/Object）事件

```js
dom.addeventListener('abort',e=>{})           // 图像的加载被中断 <object>
dom.addeventListener('beforeunload',e=>{})    // 该事件在即将离开页面（刷新或关闭）时触发
dom.addeventListener('error',e=>{})           // 在加载文档或图像时发生错误 <object>, <body>和 <frameset>
dom.addeventListener('hashchange',e=>{})      // 该事件在当前 URL 的锚部分发生修改时触发
dom.addeventListener('load',e=>{})            // 一张页面或一幅图像完成加载
dom.addeventListener('pageshow',e=>{})        // 该事件在用户访问页面时触发
dom.addeventListener('pagehide',e=>{})        // 该事件在用户离开当前网页跳转到另外一个页面时触发
dom.addeventListener('resize',e=>{})          // 窗口或框架被重新调整大小
dom.addeventListener('scroll',e=>{})          // 当文档被滚动时发生的事件
dom.addeventListener('unload',e=>{})          // 用户退出页面。 ( <body> 和 <frameset>)
```

#### 表单事件

```js
dom.addeventListener('input',e=>{})           // 元素获取用户输入时触发
dom.addeventListener('select',e=>{})          // 用户选取文本时触发 ( <input> 和 <textarea>)
dom.addeventListener('change',e=>{})          // 该事件在表单元素的内容改变时触发( <input>, <keygen>, <select>, 和 <textarea>)
dom.addeventListener('focus',e=>{})           // 元素获取焦点时触发
dom.addeventListener('reset',e=>{})           // 表单重置时触发
dom.addeventListener('submit',e=>{})          // 表单提交时触发
dom.addeventListener('blur',e=>{})            // 元素失去焦点时触发
```

#### 拖拽事件

```js
dom.addeventListener('dragstart', e=>{})      // 该事件在用户开始拖动元素时触发
dom.addeventListener('drag',e=>{})            // 该事件在元素正在拖动时触发
dom.addeventListener('dragend', e=>{})        // 该事件在用户完成元素的拖动时触发
dom.addeventListener('dragover',e=>{})        // 该事件在拖动元素在放置目标上时触发
dom.addeventListener('dragenter',e=>{})       // 该事件在拖动的元素进入放置目标时触发
dom.addeventListener('dragleave',e=>{})       // 该事件在拖动元素离开放置目标时触发
dom.addeventListener('drop',e=>{})            // 该事件在拖动元素放置在目标区域时触发
```

#### 剪贴板事件

```js
dom.addeventListener('copy',e=>{})            // 该事件在用户拷贝元素内容时触发
dom.addeventListener('cut',e=>{})             // 该事件在用户剪切元素内容时触发
dom.addeventListener('paste',e=>{})           // 该事件在用户粘贴元素内容时触发

// 实例展示
const content = document.querySelector('.content')
content.addeventListener('copy', event => {
  const selection = document.getSelection();
  event.clipboardData.setData('text/plain', selection.toString().toUpperCase());
  event.preventDefault();
  // Clipboardevent {isTrusted: true, clipboardData: DataTransfer, type: 'copy', target: p, currentTarget: div.content, …}
})
```

#### 打印事件

```js
dom.addeventListener('afterprint',e=>{})      // 该事件在页面已经开始打印，或者打印窗口已经关闭时触发
dom.addeventListener('beforeprint',e=>{})     // 该事件在页面即将开始打印时触发
```

#### 多媒体事件

```js
dom.addeventListener('abort',e=>{})           // 事件在视频/音频（audio/video）终止加载时触发
dom.addeventListener('anplay',e=>{})          // 事件在用户可以开始播放视频/音频（audio/video）时触发
dom.addeventListener('canplaythrough',e=>{})  // 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发
dom.addeventListener('durationchange',e=>{})  // 事件在视频/音频（audio/video）的时长发生变化时触发
dom.addeventListener('ended',e=>{})           // 事件在视频/音频（audio/video）播放结束时触发
dom.addeventListener('error',e=>{})           // 事件在视频/音频（audio/video）数据加载期间发生错误时触发
dom.addeventListener('loadeddata',e=>{})      // 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发
dom.addeventListener('loadedmetadata',e=>{})  // 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发
dom.addeventListener('pause',e=>{})           // 事件在视频/音频（audio/video）暂停时触发
dom.addeventListener('play',e=>{})            // 事件在视频/音频（audio/video）开始播放时触发
dom.addeventListener('timeupdate',e=>{})      // 事件在当前的播放位置发送改变时触发
dom.addeventListener('volumechange',e=>{})    // 事件在音量发生改变时触发
dom.addeventListener('seeked',e=>{})          // 事件在用户重新定位视频/音频（audio/video）的播放位置后触发
```

#### 动画事件

```js
dom.addeventListener('animationend',e=>{})          // 该事件在 CSS 动画结束播放时触发
dom.addeventListener('animationiteration',e=>{})    // 该事件在 CSS 动画重复播放时触发
dom.addeventListener('animationstart',e=>{})        // 该事件在 CSS 动画开始播放时触发
```

#### 过渡事件

```js
dom.addeventListener('transitionend',e=>{})     // 该事件在 CSS 完成过渡后触发
```

#### 触摸事件

```js
dom.addeventListener("touchstart", e =>{}, false)
dom.addeventListener("touchend", e =>{}, false)
dom.addeventListener("touchmove", e =>{}, false)
```

### 自定义事件

**1. new event**

此 event 是 event 但非 event，event 是根也是魂。

```js
const ev = new event('click')
dom.dispatchevent(ev)
```

**2. new Customevent**

```js
const ev = new Customevent('click',{detail:{}})
dom.dispatchevent()
```

**3. dispatchevent**

```js
dom.dispatchevent(new Customevent('click'))
dom.dispatchevent(new event('click'))
```

**4. addeventListener**

```js
window.addeventListener('click',e=>{},false)
dom.addeventListener('input',e=>{},false)
```

**5. removeeventListener**

```js
dom.removeeventListener('mouseleave',e=>{})
```

### 事件模型

三个阶段：事件捕获阶段、目标阶段、事件冒泡阶段。

![](https://www.programminghunter.com/images/53/9d/9dfa27801cc26d6a25d8ab9d86fa77d5.png)
[](https://pic2.zhimg.com/v2-9fd169cac0137e94d76ff9d7da7166bc_1440w.jpg?source=172ae18b)

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <div class="title">
      <p class="content">123</p>
    </div>
  </body>
</html>
```

```js
window.addeventListener('click',e=>{console.log('window-captrue')},true)
window.addeventListener('click',e=>{console.log('window-bubbles')},false)
document.addeventListener('click',e=>{console.log('document-captrue')},true)
document.addeventListener('click',e=>{console.log('document-bubbles')},false)
document.documentElement.addeventListener('click',e=>{console.log('html-captrue')},true)
document.documentElement.addeventListener('click',e=>{console.log('html-bubbles')},false)
document.body.addeventListener('click',e=>{console.log('body-captrue')},true)
document.body.addeventListener('click',e=>{console.log('body-bubbles')},false)
document.querySelector('div').addeventListener('click',e=>{console.log('div-captrue')},true)
document.querySelector('div').addeventListener('click',e=>{console.log('div-bubbles')},false)
document.querySelector('p').addeventListener('click',e=>{console.log('p-captrue')},true)
document.querySelector('p').addeventListener('click',e=>{console.log('p-bubbles')},false)
// html-captrue
// body-captrue
// div-captrue
// p-captrue
// p-bubbles
// div-bubbles
// body-bubbles
// html-bubbles
```

### 事件对象

事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个event对象，所有的事件都是这个对象的实例，或者说继承了event.prototype对象。event对象本身就是一个构造函数，可以用来生成新的实例。event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。

bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。
cancelable：布尔值，可选，默认为false，表示事件是否可以被取消，即能否用event.preventDefault()取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。

```js
const ev = new event('click',{
  'bubbles': true,
  'cancelable': false
})
dom.dispatchevent(ev)
```

#### 实例属性

|       属性      | 值          | 描述                                                                     |
| :-----------: | ---------- | ---------------------------------------------------------------------- |
|    bubbles    | true/false | 表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 event 实例是否可以冒泡                             |
|   eventPhase  | 0/1/2/3    | eventPhase属性返回一个整数常量，表示事件目前所处的阶段:事件目前没有发生、事件目前处于捕获阶段、事件到达目标节点、事件处于冒泡阶段 |
|   cancelable  | true/false | 表示事件是否可以取消                                                             |
|  cancelBubble | true/false | 相当于执行 event.stopPropagation()                                          |
| currentTarget | DOM        | 事件当前正在通过的节                                                             |
|     target    | DOM        | 事件的原始触发节点（event.target）                                                |
|      type     | String     | 表示事件类型                                                                 |
|   timeStamp   | 毫秒时间戳      | 表示事件发生的时间,它是相对于网页加载成功开始计算的                                             |
|   isTrusted   | true/false | 表示该事件是否由真实的用户行为产生                                                      |

```js
const ev = new Event('click');
ev.type // "click"
ev.eventPhase // 0
```

#### 实例方法

| 方法/属性                      | 描述                                                       |
| -------------------------- | -------------------------------------------------------- |
| preventDefault()           | 方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了 |
| stopPropagation()          | 阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数  |
| stopImmediatePropagation() | 阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点                    |
| composedPath()             | 返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点                         |
| eventPhase                 | 属性返回一个整数常量，表示事件目前所处的阶段。该属性只读，                            |
| bubbless                   | 属性返回一个布尔值，表示当前事件是否会冒泡                                    |
| cancelable                 | 属性返回一个布尔值，表示事件是否可以取消                                     |

[](https://wangdoc.com/javascript/events/event.html)
